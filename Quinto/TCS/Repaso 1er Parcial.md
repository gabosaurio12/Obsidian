## Cuestionario de Repaso

Responda a las siguientes preguntas en dos o tres oraciones, basándose exclusivamente en el contexto proporcionado.

1. ¿Cuál es el objetivo principal de una Llamada a Procedimiento Remoto (RPC) y qué componente se utiliza para lograr la transparencia?
2. Describa dos problemas relacionados con la transferencia de parámetros en RPC entre máquinas diferentes y la solución estándar propuesta.
3. ¿Qué es un ORM como Entity Framework y cuál es su propósito fundamental en el desarrollo de software con .NET?
4. Explique la diferencia clave entre _Lazy Loading_ y _Eager Loading_ en el contexto de Entity Framework.
5. ¿Cuáles son las tres capas que define el modelo Cliente-Servidor y por qué se considera más eficiente que el modelo OSI para su propósito?
6. Describa el método de direccionamiento que utiliza un "servidor de nombres" en el modelo Cliente-Servidor y mencione una de sus desventajas.
7. ¿Qué es una Revisión Formal en el desarrollo de software y cuál es el rol del "Moderador" dentro de este proceso?
8. Según los materiales, ¿por qué la "propiedad colectiva" y las revisiones de código son beneficiosas para un equipo de desarrollo?
9. ¿Qué es un "Endpoint" en WCF y cuáles son los tres componentes que lo conforman?
10. Defina qué es un "Behaviour" en el contexto de Service Runtime de WCF y mencione dos ejemplos de sus tipos.

--------------------------------------------------------------------------------

## Clave de Respuestas

1. El objetivo de una Llamada a Procedimiento Remoto (RPC) es permitir que los programas invoquen procedimientos localizados en otras máquinas de forma transparente, similar a una llamada a un procedimiento local (LPC). Para lograr esta transparencia, se utiliza una copia del procedimiento llamada "resguardo del cliente" (Client Stub), que se encarga de empaquetar los parámetros, enviarlos como mensaje al servidor y bloquearse hasta recibir una respuesta.
2. Un problema es la diferente representación de enteros (complemento a 1 vs. complemento a 2) y otro es la enumeración de bytes (little endian vs. big endian). La solución estándar es diseñar una forma canónica o estándar de red para representar los tipos de datos y solicitar a los emisores que conviertan los datos a este formato antes de enviarlos.
3. Un ORM (Object Relational Mapper) como Entity Framework es una técnica que mapea los objetos de un programa con las tablas de una base de datos. Su propósito es simplificar el acceso y la manipulación de bases de datos para los desarrolladores de .NET, permitiéndoles trabajar directamente con objetos en el código y evitando la necesidad de escribir manualmente consultas SQL para operaciones CRUD.
4. En _Lazy Loading_, las entidades relacionadas solo se cargan cuando se accede a ellas por primera vez, generando consultas adicionales por demanda. En contraste, _Eager Loading_ carga las entidades relacionadas inmediatamente junto con la entidad principal en una sola consulta inicial, utilizando el método `Include()`.
5. El modelo Cliente-Servidor define solo tres capas: la capa física, la de enlace y la de solicitud/respuesta. Se considera más eficiente que el modelo OSI porque no es necesario procesar media docena de capas cada vez que se quiere enviar un mensaje, simplificando la comunicación directa entre cliente y servidor.
6. En este método, cuando un cliente necesita contactar a un servidor, primero envía una solicitud a un servidor de nombres centralizado para obtener la dirección (número de máquina) del servidor requerido. Una desventaja principal es que este servidor de nombres es un componente centralizado, y si falla, el servicio se interrumpe, además de presentar problemas de consistencia si se duplica.
7. Una Revisión Formal es un proceso estructurado y riguroso para detectar defectos en el código, usualmente en proyectos críticos o de alto riesgo. El rol del "Moderador" es planificar y organizar la revisión, convocar a los participantes, mantener la reunión enfocada y verificar que los defectos señalados sean corregidos en la fase de seguimiento.
8. Estas prácticas son beneficiosas porque mejoran la calidad del software y disminuyen el tiempo de desarrollo. Permiten que los programadores avanzados diseminen su conocimiento y experiencia a los novatos, ayudando a superar los "puntos ciegos" que los desarrolladores pueden tener y a reducir la cantidad de defectos insertados en el código.
9. Un endpoint en WCF define la dirección donde un mensaje será enviado o recibido y especifica los mecanismos de comunicación. Está compuesto por tres elementos: la Dirección (una URI donde se localiza el servicio), el Binding (que define cómo se comunica el endpoint) y los Contratos (la colección de operaciones que el endpoint expone).
10. Un "Behaviour" en WCF define la respuesta o el comportamiento del servicio ante ciertos escenarios o situaciones específicas. Es necesario definirlos para controlar cómo se procesan los mensajes y se gestiona el servicio; dos ejemplos son _Throttling_, que administra el número de mensajes procesados, y _Error_, que define el resultado ante un error interno del servicio.

--------------------------------------------------------------------------------

## Preguntas de Ensayo

1. Analice y compare las estrategias de manejo de fallas en RPC (cliente no localiza servidor, pérdida de mensajes, falla del servidor) con los diferentes tipos de "Behaviours" en WCF (Error, Transaction, Dispatch). ¿Cómo cada arquitectura aborda el problema de la fiabilidad en un entorno distribuido?
2. Explique cómo el concepto de "inversión de control" mencionado en el contexto de los frameworks se manifiesta en la arquitectura de Entity Framework, específicamente en la relación entre el código del desarrollador, los Data Providers y el motor de la base de datos.
3. Discuta las ventajas y desventajas de los tres enfoques de desarrollo en Entity Framework (Model First, Code First, Database First). ¿En qué tipo de proyectos o escenarios sería más recomendable utilizar cada uno de ellos?
4. Compare el proceso de una "Revisión Formal" con las "Inspecciones formales" y los "walk-throughs". Describa los roles, el nivel de rigurosidad y los objetivos de cada técnica, y argumente cuándo sería apropiado aplicar cada una en un ciclo de desarrollo de software.
5. Elabore un argumento sobre cómo la combinación de contenedores, automatización de pruebas (CI/CD) y el uso de frameworks de desarrollo aborda los desafíos del desarrollo de software actual, como las limitaciones de tiempo, los defectos y el mantenimiento.

--------------------------------------------------------------------------------

## Glosario de Términos Clave

|                                             |                                                                                                                                                                                                                                                  |
| ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Término                                     | Definición                                                                                                                                                                                                                                       |
| **Arquitectura sin servidor (serverless)**  | Un enfoque arquitectónico donde se comprenden los conceptos detrás de ciertas arquitecturas, identificando sus beneficios, limitaciones y procedimientos de despliegue.                                                                          |
| **Behaviour (WCF)**                         | Define la respuesta que se da a ciertos escenarios en el Service Runtime de WCF. Controla aspectos como el número de mensajes, el manejo de errores, la creación de instancias, transacciones, etc.                                              |
| **Binding (WCF)**                           | Componente de un endpoint que define cómo dicho endpoint se comunica con el mundo exterior.                                                                                                                                                      |
| **Code First (Entity Framework)**           | Enfoque de desarrollo donde se escriben primero las clases en C# y Entity Framework genera la base de datos a partir de ellas. Ofrece alta flexibilidad y se recomienda para proyectos centrados en el código.                                   |
| **Contrato (WCF)**                          | Capa que contiene información sobre los métodos que un servicio expondrá al cliente. Existen contratos de servicio, de información y de mensaje.                                                                                                 |
| **Database First (Entity Framework)**       | Enfoque de desarrollo donde, a partir de una base de datos existente, Entity Framework genera las clases del modelo. Se recomienda para proyectos con una base de datos preexistente (legacy).                                                   |
| **Data Provider (Entity Framework)**        | Componente que actúa como puente entre Entity Framework y un motor de base de datos específico. Traduce consultas LINQ/Entity SQL a SQL nativo, las ejecuta y convierte los resultados en objetos .NET.                                          |
| **Eager Loading**                           | Técnica en Entity Framework donde las entidades relacionadas se cargan inmediatamente junto con la entidad principal en una sola consulta inicial. Se utiliza `Include()` y es rápido si se necesitan los datos relacionados desde el principio. |
| **Endpoint (WCF)**                          | Define la dirección donde un mensaje será enviado o recibido. Está compuesto por una Dirección (Address), un Mecanismo de Comunicación (Binding) y una colección de operaciones (Contratos).                                                     |
| **Entity Framework (EF)**                   | Un ORM (Object Relational Mapper) de Microsoft para .NET que simplifica el acceso a bases de datos al permitir a los desarrolladores trabajar con objetos en lugar de escribir consultas SQL manualmente.                                        |
| **Inspección formal**                       | Un tipo de revisión de código enfocada en la detección de defectos, especialmente en áreas que han presentado problemas anteriormente.                                                                                                           |
| **Inversión de control**                    | Un principio exhibido por los frameworks donde el flujo de control del programa es dictado por el framework (a través de callbacks, por ejemplo) en lugar de por el código de la aplicación.                                                     |
| **Lazy Loading**                            | Técnica en Entity Framework donde las entidades relacionadas solo se cargan cuando se accede a ellas por primera vez, bajo demanda. Puede generar múltiples consultas a la base de datos pero usa menos memoria inicialmente.                    |
| **Llamada a un Procedimiento Remoto (RPC)** | Mecanismo que permite a un programa invocar un procedimiento (o función) que se encuentra localizado en otra máquina, dentro de un espacio de direcciones distinto.                                                                              |
| **Model First (Entity Framework)**          | Enfoque de desarrollo donde se diseña un diagrama visual del modelo de datos y Entity Framework genera la base de datos a partir de este.                                                                                                        |
| **Modelo Cliente-Servidor**                 | Modelo de comunicación que estructura un sistema como un conjunto de procesos servidores que ofrecen servicios a procesos usuarios, llamados clientes.                                                                                           |
| **ORM (Object Relational Mapper)**          | Técnica de desarrollo de software que mapea los objetos de un programa y las tablas de una base de datos, facilitando la interacción con la base de datos a través de objetos.                                                                   |
| **Primitivas con bloqueo (síncronas)**      | Llamadas al sistema (como `send` o `receive`) en las que el proceso que las invoca se bloquea y espera hasta que la operación se complete.                                                                                                       |
| **Primitivas sin bloqueo (asíncronas)**     | Llamadas al sistema en las que el control se regresa de inmediato al emisor, permitiendo el trabajo en paralelo mientras el mensaje es gestionado en un buffer.                                                                                  |
| **Resguardo del cliente (Client Stub)**     | Una copia de un procedimiento remoto que reside en la máquina cliente. Se encarga de empaquetar los parámetros en un mensaje (serialización), enviarlo al servidor y esperar la respuesta.                                                       |
| **Revisión Formal**                         | Un proceso estructurado y riguroso, con etapas definidas (planeación, preparación, reunión, corrección, seguimiento), para detectar defectos en el código, especialmente en proyectos de alto riesgo.                                            |
| **Serialización**                           | El proceso de empaquetar los parámetros de una función en un mensaje para ser transmitido a través de la red, como lo realiza el resguardo del cliente en un sistema RPC.                                                                        |
| **Transparencia (en RPC)**                  | El objetivo de hacer que una llamada a un procedimiento remoto parezca y funcione de manera idéntica a una llamada a un procedimiento local, ocultando la comunicación de red subyacente.                                                        |
| **WCF (Windows Communication Foundation)**  | Un framework de Microsoft para construir aplicaciones orientadas al servicio, cuyo principal objetivo es la interoperabilidad para comunicarse con un servidor.                                                                                  |